Types
    Primitive Types
        nil
        number
        boolean
        string
    Object Types
        list
        table
Expressions
    Binary
        Logical Expression
        Binary Expression
    CallExpression
Statements

Variables
    Global & Local Variables
        - any variable name is assumed to be global unless local is use
        - default value is nil
        - local variables only work within the scope
        A           -- global variable
        local A     -- local variable
        > local ident
        | ident
    Variable Access "index a table"
        A.B same as A['B']
        > prefixexpr . identifier
        > prefixexpr [ expr ]

Statement
    Blocks
        statement-list
        > ...statement
    Empty Statement
        empty-statement
        > ;
    Function Call
        call
        > expr ( args )
    Compound-Statement
        compound-statement
        > do block
    Assign-Statement
        assign-statement
        > var-list = expr-list
        | local var-list = expr-list
        expr-list
        > ...expr
        var-list
        > ...var
        1
            code
                x = 5
            result
                push 5
                store x
                clear
        2
            code
                x = 1,2
            result
                push 2
                push 1
                store x
                clear
        3
            code
                x,y = 1
            result
                push 1
                store x
                store y
                clear
        4
            code
                function test()
                    return 5,1
                end
                x,y,z = test(), test()
            result
                call test
                    push 1
                    push 5
                call test
                    push 1
                    push 5
                store z
                store y
                store x
                clear
Control Structures
    IfStatement
        if-clause
        > if expr then block
        else-if-clause
        > elseif expr then block
        else-clause
        > else block
        if-statement
        > if-clause ...elseif-clause else-clause? end
        1
            code
                if a then return b
                else if c then return d
                else return e end
            result
                push a
                brf L1
                push b
                jr
                L1:
                push c
                brf L2
                push d
                jr
                L2:
                push e
                jr
    WhileStatement
        while
        > while expr do block end
    RepeatUntilStatement

Tables
    {
        [ expr ] = expr
        name = expr
    }

    expr
    > ident
    | string
    | number
    | boolean
    | nil
    | vararg
    | table
    | binary-expression
    | logical-expression

call
    local e1 = Effect.CreateEffect(c)
    e1:SetCode(EVENT_TYPE_DRAW)

    same as

    e1.SetCode(e1, EVENT_TYPE_DRAW)

keywords
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while

Token
     +     -     *     /     %     ^     #
     &     ~     |     <<    >>    //
     ==    ~=    <=    >=    <     >     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...

---

# Example

```lua
function Link.ConditionFilter(c,f,lc,tp)
	return c:IsCanBeLinkMaterial(lc,tp) and (not f or f(c,lc,SUMMON_TYPE_LINK|MATERIAL_LINK,tp))
end
```

## Step 1

```Typescript
type Link = {
    ConditionFilter(
            c:  $type_c,
            f:  $type_f,
            lc: $type_lc,
            tp: $type_tp
        ) : $return_type_ConditionFilter
}
```

analyze symbols:
    1) look at: 'c:IsCanBeLinkMaterial(lc,tp)'
        lookup any predefined functions that have 'IsCanBeLinkMaterial'
        result:
            Card.IsCanBeLinkMaterial(
                c:Card,
                linkc?: Card,
                player?: int
            ): boolean
        $type_c = Card
        $type_lc = Card
        $type_tp = number

updated code from (1)
```
type Link = {
    ConditionFilter(
            c:  Card,
            f:  $type_f,
            lc: Card,
            tp: number
        ) : $return_type_ConditionFilter
}
```

## Step 2

2) look at 'f(c,lc,SUMMON_TYPE_LINK|MATERIAL_LINK,tp)'
    2.1) f is callable
    2.2) insert inferred types
    2.3) evaluate expressions
    result:
        $type_f = (
            c: Card, // <- because $type_tp is number from Card.IsCanBeLinkMaterial@argument[0]
            lc: Card, // <- because $type_tp is number from Card.IsCanBeLinkMaterial@argument[1]
            _2: number // <- BinaryExpression typeof a|b is number
            tp: number // <- because $type_tp is number from Card.IsCanBeLinkMaterial@argument[2]
        ) => $return_type_f

updated code from (2)

```Typescript
type Link = {
    ConditionFilter(
            c:  Card,
            f:  (
                c:  Card,
                lc: Card,
                _2: number,
                tp: number
            ) => $return_type_f,
            lc: Card,
            tp: number
        ) : $return_type_ConditionFilter
}
```

## Step 3

look at 'return c:IsCanBeLinkMaterial(lc,tp) and (not f or f(c,lc,SUMMON_TYPE_LINK|MATERIAL_LINK,tp))'
    3.1) let's look at the expression tree
    3.2) replace expressions with inferred types, when it's a call add the return type
        result:
            return #1:boolean and (#2:(not f) or #3:$return_type_f)
            return #1 && #2 || #3
        3.2.a) Variation a
            for all types that can be inferred, create union
            result: return-type is boolean
        3.2.b) Variation b
            for all types, create union, if there's a type that cannot be inferred, just return any (always true, because any is any)
            result: return-type is any
        3.2.b) Variation c
            for all types, create union (readable and always true)
            result: return-type is any | $return_type_f
            WARNING:
                this would mean, using generic arguments


```Typescript
type Link = {
    ConditionFilter<RETURN_F>(
            c:  Card,
            f:  (
                c:  Card,
                lc: Card,
                _2: number,
                tp: number) => RETURN_F,
            lc: Card,
            tp: number
            ) : boolean | RETURN_F
}

## Result

```Typescript
type Link = {
    ConditionFilter<E>(
        c: Card,
        f: (c: Card, lc: Card, _2: number, tp: number) => E,
        lc: Card,
        tp: number
    ) boolean | E
}
```

conclusion and requirements:
    1) Check Member-Expressions 'Link.ConditionFilter'
        is A.B a Member-Expression
        There must be a type A = { B }
        because this is not a legal type: Assign-Statement or Function-Declaration is required
        Function-Declaration:
            function A.B (arguments) end
            There must be a type A = { B() }
        Assign-Statement:
            A.B = C
            There must be a type A = { B: typeof C }
    2) Check Function
        function Link.ConditionFilter(c,f,lc,tp)
        	return c:IsCanBeLinkMaterial(lc,tp) and (not f or f(c,lc,SUMMON_TYPE_LINK|MATERIAL_LINK,tp))
        end
        2.2) Check-Parameter
            c, f, lc, tp \in Parameter
            \forall p in Parameter
                create pseudo type p : $type_p
                see usage of all p in scope
                case p:SomeFunction(...)
                    lookup type T that have 'SomeFunction', so that 'T.SomeFunction(element of T)'
                    $type_p = T
                case p(a_0,...,a_m)
                    $type_p = (a_0,...,a_m) => $type_return_p
                case p + number
                    $type_p = number
        2.3)
            Check-Return Type

1. Define a function Link.ConditionFilter with parameters c, f, lc, and tp.
2. Inside the function, create a boolean expression that combines the following conditions:
   a. Check if c:IsCanBeLinkMaterial(lc, tp) is true. Use predefined function definitions to infer the types for c, lc, and tp.
   b. Check if f is not null, and if so, call the function f with arguments c, lc, SUMMON_TYPE_LINK | MATERIAL_LINK, and tp. Infer types for these arguments.
   c. Combine the results of the above conditions using logical operators (AND and OR) to get the final return value.
3. Define a type Link with a method ConditionFilter that has the following parameters and return type:
   - c of type $type_c
   - f of type $type_f
   - lc of type $type_lc
   - tp of type $type_tp
   - The return type is $return_type_ConditionFilter
4. Analyze symbols and predefined functions:
   a. Look up the predefined function Card.IsCanBeLinkMaterial to infer the types for c, lc, and tp.
   b. Infer types for the function f by examining its arguments and expressions.
5. Update the type definitions to use inferred types:
   a. Update the ConditionFilter method in the Link type to use the inferred types for parameters and return type.
6. Result:
   - The Link type now has a ConditionFilter method that can accept a generic type E for the return type.
7. Conclusion and Requirements:
   a. Check that Member-Expressions like 'Link.ConditionFilter' are correctly defined and that there are matching type definitions.
   b. Verify that the Function-Declaration for Link.ConditionFilter is properly defined with the expected parameters and return type.
   c. Check the parameters of the function for inferred types.
   d. Check the return type of the function for correctness.

---

Tasks
    Create Project Environment
        Predefined Structures
            lua
                e.g.: table.insert
            backend
                e.g.: Group.Select(pgroup: Group, playerid: uint8_t, min: uint16_t, max: uint16_t): Group

        In order to do that:
            1)
                type Signature
                    type: 'Group'
                    identifier: 'Select'
                    returns:
                        [0]
                            type: 'Group'
                    parameter:
                        [0]
                            name: 'pgroup'
                            type: 'Group'
                        [1]
                            name: 'playerid'
                            type: 'uint8_t'
                        [2]
                            name: 'min'
                            type: 'uint16_t'
                        [3]
                            name: 'max'
                            type: 'uint16_t'
                if parameter [0].type same as Signature.type, this is allowed:
                    if type(e1) == 'Group'
                    e1:Select(playerid: uint8_t, min: uint16_t, max: uint16_t)
            2)
                scrap wiki and save signature for each entry
            3)
                e.g.: e1:Select(...)
                <ident1="e1">:<ident2="select">(...)
                set: Set<Signature>
                for each signature of signatures
                    if signature.identifier === ident2
                        type(e1) = signature.type


function Link.ConditionFilter(c,f,lc,tp)
	return c:IsCanBeLinkMaterial(lc,tp) and (not f or f(c,lc,SUMMON_TYPE_LINK|MATERIAL_LINK,tp))
end

chunk $0
    _declarations:
        $26 = {
            $27 = ($2, $3, $4, $5) => $6
        }
    body:
        [0]
            function-declaration $1
                // this.node.local == false
                // if this.identifier.kind === member-expression
                //     then if
                identifier:
                    member-expression $25
                        // Indexer is '.'.
                        // Take this.base add member this.identifier
                        base:
                            identifier $26
                                name: Link
                        identifier:
                            identifier $27
                                name: ConditionFilter
                        indexer: .
                parameter:
                    [0]
                        identifier $2
                            _stopPropagation: true
                            name: c
                    [1]
                        identifier $3
                            _stopPropagation: true
                            name: f
                    [2]
                        identifier $4
                            _stopPropagation: true
                            name: lc
                    [3]
                        identifier $5
                            _stopPropagation: true
                            name: tp
                body:
                    [0]
                        return-statement $6
                            arguments:
                                [0]
                                    logical-expression $7
                                        operator: and
                                        left:
                                            call-expression $8
                                                signature:
                                                    Card.IsCanBeLinkMaterial($2 : Card, $4 : Card, $5 : int): boolean
                                                    //  Signature
                                                    //      type Card
                                                    //      name: IsCanBeLinkMaterial
                                                    //      returns: [ boolean ]
                                                    //      parameter: [ [0] = Card, [1] = Card, [2] = int ]
                                                base:
                                                    member-expression $9
                                                        base:
                                                            identifier $10
                                                                _link: $2
                                                                _type: Card
                                                                _flag: UnshiftArgument
                                                                _signature: { IsCanBeLinkMaterial() }
                                                                name: c
                                                        identifier:
                                                            identifier $11
                                                                name: IsCanBeLinkMaterial
                                                        indexer: :
                                                arguments:
                                                    [0]
                                                        identifier $12
                                                            _link: $4
                                                            name: lc
                                                    [1]
                                                        identifier $13
                                                            _link: $5
                                                            name: tp
                                        right:
                                            logical-expression $14
                                                _flow:
                                                    // f extends false | nil
                                                    //     ? f._type = false | nil
                                                    //     : f._type = Exclude<false | nil>
                                                operator: or
                                                left:
                                                    unary-expression $15
                                                        _type: boolean
                                                        operator: not
                                                        argument:
                                                            identifier $16
                                                                _link: $3
                                                                name: f
                                                right:
                                                    call-expression $17
                                                        signature:
                                                            $3($2 : Card, $4 : int, number, $5)
                                                        base:
                                                            identifier $18
                                                                _link: $3
                                                                name: f
                                                        arguments:
                                                            [0]
                                                                identifier $19
                                                                    _link: $2
                                                                    name: c
                                                            [1]
                                                                identifier $20
                                                                    _link: $4
                                                                    name: lc
                                                            [2]
                                                                binary-expression $21
                                                                    _type: number
                                                                    operator: |
                                                                    left:
                                                                        identifier $22
                                                                            _link: constants.SUMMON_TYPE_LINK
                                                                            name: SUMMON_TYPE_LINK
                                                                    right:
                                                                        identifier $23
                                                                            _link: constants.MATERIAL_LINK
                                                                            name: MATERIAL_LINK
                                                            [3]
                                                                identifier $24
                                                                    _link: $5
                                                                    name: tp

---


---

